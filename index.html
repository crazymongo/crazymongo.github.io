<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>crazymongo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="crazymongo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="crazymongo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="crazymongo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="crazymongo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">crazymongo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-HashSet和HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/13/HashSet和HashMap/" class="article-date">
  <time datetime="2016-01-13T09:59:07.000Z" itemprop="datePublished">2016-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/13/HashSet和HashMap/">HashSet、HashMap和Hashtable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>HashSet</strong></p>
<p>HashSet实现了Set接口，内部由哈希表（实际上是HashMap实例）支持。HashSet不保证集合的迭代顺序，特别是它不保证该顺序恒久不变。HashSet允许null元素。</p>
<p>HashSet是非同步的，如果多个线程同时访问集合，且至少一个线程修改这个集合，那么这个集合在外部必须被同步。避免偶然地不同步访问集合发生，我们在创建set时最好使用Collections.synchronizedSet(new HashSet(…))方法。</p>
<p>通过HashSet的iterator()方法获得的迭代器是“fail-fast”：在获取迭代器之后，除了通过迭代器本身移除元素之外，其它任何对集合的修改都将导致迭代器抛出ConcurrentModificationException。因此，面对并发修改，迭代器很快就会失败，而不冒将来在某个不确定时间发生任何不确定行为的风险。</p>
<p><strong>HashMap</strong></p>
<p>HashMap是基于哈希表的Map接口的实现。此实现提供所有可选的映射操作，并允许null值和null键。（除了非同步和允许使用null之外，HashMap类与Hashtable大致相同）。HashMap不保证映射的顺序，特别是它不保证顺序恒久不变。</p>
<p>有两个参数影响HashMap的性能，及初识容量和加载因子。容量是哈希表中桶的数量，初识容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对哈希表进行rehash操作（即重建内部数据结构），从而哈希表将具有大约两倍的容量。</p>
<p>通常，默认加载因子（.75）在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本。</p>
<p>HashMap是非同步的，如果多个线程同时访问集合，且至少一个线程修改这个集合，那么这个集合在外部必须被同步。避免偶然地不同步访问集合发生，我们在创建set时最好使用Collections.synchronizedMap(new HashMap(…))方法。</p>
<p>由所有此类的“collection 视图方法”所返回的迭代器都是快速失败 的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
<p><strong>Hashtable</strong></p>
<p>Hashtable实现一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以作为键或值。</p>
<p>为了成功地在哈希表中存储和获取对象，用作键的对象必须实现hashCode方法和equals方法。</p>
<p>Hashtable是同步的，如果程序不需要线程安全的哈希表实现，推荐使用HashMap。如果需要线程安全、高并发的哈希表实现，推荐使用ConcurrentHashMap。</p>
<p><strong>TreeMap</strong></p>
<p>TreeMap是基于红黑树（Red-Black tree）的NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建时提供的Comparator进行排序，具体取决于使用的构造方法。</p>
<p>TreeMap为方法contrainKey、get、put和remove等操作提供受保证的log(n)时间开销。</p>
<p><strong>TreeSet</strong></p>
<p>TreeSet是基于TreeMap的NavigableSet实现。使用元素的自然顺序对元素进行排序，或者根据创建Set时提供的Comparator进行排序。此实现为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/13/HashSet和HashMap/" data-id="cik95uvzj001m08pxo1pjwgkv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashSet-HashMap-Hashtable/">HashSet HashMap Hashtable</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-UniversalImageLoader-MemoryCache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/03/Android-UniversalImageLoader-MemoryCache/" class="article-date">
  <time datetime="2016-01-03T11:21:37.000Z" itemprop="datePublished">2016-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/03/Android-UniversalImageLoader-MemoryCache/">Android-UniversalImageLoader-MemoryCache</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>UniversalImageLoader提供多种内存缓存策略，大致分为三类：</p>
<ul>
<li>内存缓存大小固定的内存缓存策略</li>
<li>可以由用户设定内存缓存空间大小的缓存策略</li>
<li>没有内存大小限定的缓存策略</li>
</ul>
<p>首先，我们先来学习一下内存缓存大小固定的内存缓存策略，其中框架提供了多种实现，包括：FIFOLimitedMemoryCache, LargestLimitedMemoryCache, UsingFreqLimitedMemoryCache, LRULimitedMemoryCache。这几个类都继承了抽象类LimitedMemoryCache。而LimitedMemoryCache派生自BaseMemoryCache。</p>
<p>抽象类BaseMemoryCache基本实现了对象的软缓存，其内部通过HashMap<string, reference<bitmap="">&gt;())的对象来保存对象引用。</string,></p>
<p>抽象类LimitedMemoryCache基本实现了对象的硬缓存，其内部通过LinkedList<bitmap>的对象来保存对象引用。该类规定了最大的内存缓存大小为16M。当缓存大小超过这个值的时候，就会根据某种方式移除某些对象。子类需要提供移除某些对象的策略。</bitmap></p>
<p>FIFOLimitedMemoryCache每次移除最先进入队列的对象，其策略如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Bitmap&gt; queue = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;Bitmap&gt;());

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function">Bitmap <span class="title">removeNext</span><span class="params">()</span> </span>{
    <span class="function"><span class="keyword">return</span> queue.<span class="title">remove</span><span class="params">(<span class="number">0</span>)</span></span>;
}
</code></pre><p>UsingFreqLimitedMemoryCache每次移除使用率最小那个对象，其实现如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, <span class="type">Integer</span>&gt; usingCounts = Collections.synchronizedMap(new HashMap&lt;Bitmap, <span class="type">Integer</span>&gt;());

@Override
<span class="keyword">protected</span> Bitmap removeNext() {
    <span class="type">Integer</span> minUsageCount = null;
    Bitmap leastUsedValue = null;
    Set&lt;<span class="built_in">Entry</span>&lt;Bitmap, <span class="type">Integer</span>&gt;&gt; entries = usingCounts.entrySet();
    synchronized (usingCounts) {
        for (<span class="built_in">Entry</span>&lt;Bitmap, <span class="type">Integer</span>&gt; <span class="built_in">entry</span> : entries) {
            <span class="keyword">if</span> (leastUsedValue == null) {
                leastUsedValue = <span class="built_in">entry</span>.getKey();
                minUsageCount = <span class="built_in">entry</span>.getValue();
            } <span class="keyword">else</span> {
                <span class="type">Integer</span> lastValueUsage = <span class="built_in">entry</span>.getValue();
                <span class="keyword">if</span> (lastValueUsage &lt; minUsageCount) {
                    minUsageCount = lastValueUsage;
                    leastUsedValue = <span class="built_in">entry</span>.getKey();
                }
            }
        }
    }
    usingCounts.remove(leastUsedValue);
    <span class="keyword">return</span> leastUsedValue;
}
</code></pre><p>用户每次调用get(String key)方法时，相对于的对象的使用频率加1。</p>
<p>LargestLimitedMemoryCache每次都会移除内存占用最大的那个对象，其实现如下：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Bitmap, <span class="type">Integer</span>&gt; valueSizes = Collections.synchronizedMap(new HashMap&lt;Bitmap, <span class="type">Integer</span>&gt;());

@Override
<span class="keyword">protected</span> Bitmap removeNext() {
    <span class="type">Integer</span> maxSize = null;
    Bitmap largestValue = null;
    Set&lt;<span class="built_in">Entry</span>&lt;Bitmap, <span class="type">Integer</span>&gt;&gt; entries = valueSizes.entrySet();
    synchronized (valueSizes) {
        for (<span class="built_in">Entry</span>&lt;Bitmap, <span class="type">Integer</span>&gt; <span class="built_in">entry</span> : entries) {
            <span class="keyword">if</span> (largestValue == null) {
                largestValue = <span class="built_in">entry</span>.getKey();
                maxSize = <span class="built_in">entry</span>.getValue();
            } <span class="keyword">else</span> {
                <span class="type">Integer</span> <span class="built_in">size</span> = <span class="built_in">entry</span>.getValue();
                <span class="keyword">if</span> (<span class="built_in">size</span> &gt; maxSize) {
                    maxSize = <span class="built_in">size</span>;
                    largestValue = <span class="built_in">entry</span>.getKey();
                }
            }
        }
    }
    valueSizes.remove(largestValue);
    <span class="keyword">return</span> largestValue;
}
</code></pre><p>LRULimitedMemoryCache每次移除最近使用次数最少的那个（及LRU算法），其实现如下：</p>
<pre><code><span class="label">private</span> final <span class="preprocessor">Map</span>&lt;<span class="keyword">String, </span><span class="keyword">Bitmap&gt; </span>lruCache = Collections.synchronizedMap(new LinkedHashMap&lt;<span class="keyword">String, </span><span class="keyword">Bitmap&gt;(INITIAL_CAPACITY, </span>LOAD_FACTOR, true))<span class="comment">;</span>

<span class="comment">@Override</span>
<span class="label">protected</span> <span class="keyword">Bitmap </span>removeNext() {
    <span class="keyword">Bitmap </span>mostLongUsedValue = null<span class="comment">;</span>
    synchronized (lruCache) {
        <span class="keyword">Iterator&lt;Entry&lt;String, </span><span class="keyword">Bitmap&gt;&gt; </span><span class="keyword">it </span>= lruCache.entrySet().<span class="keyword">iterator();
</span>        <span class="preprocessor">if</span> (<span class="keyword">it.hasNext()) </span>{
            <span class="preprocessor">Entry</span>&lt;<span class="keyword">String, </span><span class="keyword">Bitmap&gt; </span><span class="preprocessor">entry</span> = <span class="keyword">it.next();
</span>            mostLongUsedValue = <span class="preprocessor">entry</span>.getValue()<span class="comment">;</span>
            <span class="keyword">it.remove();
</span>        }
    }
    return mostLongUsedValue<span class="comment">;</span>
}
</code></pre><p>接下来，我们将学习可以由用户设定内存缓存空间大小的缓存策略，框架目前只提供了LruMemoryCache实现，其内部实现原理跟LRULimitedMemoryCache一样，都是通过LinkedHashMap实现的，我们在此就不做过多讲解了。</p>
<p>最后，让我们来看一下没有内存大小限定的缓存策略，框架目前只提供了WeakMemroyCache实现，其内部实现原理就是为每个对象建立一个软引用，这样系统GC可以随时根据需要消耗对象。</p>
<pre><code>@<span class="function">Override
<span class="keyword">protected</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span>(<span class="params">Bitmap <span class="keyword">value</span></span>) </span>{
    <span class="keyword">return</span> <span class="keyword">new</span> WeakReference&lt;Bitmap&gt;(<span class="keyword">value</span>);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/03/Android-UniversalImageLoader-MemoryCache/" data-id="cik95uvzy002508px9a6sfsi4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-UniversalImageLoader-MemoryCache/">Android UniversalImageLoader MemoryCache</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Settings类初识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/25/Android-Settings类初识/" class="article-date">
  <time datetime="2015-12-25T03:57:49.000Z" itemprop="datePublished">2015-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/25/Android-Settings类初识/">Android-Settings类初识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Settings类的作用主要是提供系统级别的全局设置。</p>
<p>Settings类中包含Intent的Action常量，通过调用可以打开相应的设置界面。例如：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Activity Action: Show system settings.
 <span class="keyword">*</span> <span class="variable">&lt;p&gt;</span>
 <span class="keyword">*</span> Input: Nothing.
 <span class="keyword">*</span> <span class="variable">&lt;p&gt;</span>
 <span class="keyword">*</span> Output: Nothing.
 <span class="keyword">*</span>/
<span class="comment">@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)</span>
public static final String ACTION_SETTINGS = <span class="string">"android.settings.SETTINGS"</span>;

/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> Activity Action: Show settings to allow configuration of wireless controls
 <span class="keyword">*</span> such as Wi-Fi, Bluetooth and Mobile networks.
 <span class="keyword">*</span> <span class="variable">&lt;p&gt;</span>
 <span class="keyword">*</span> In some cases, a matching Activity may not exist, so ensure you
 <span class="keyword">*</span> safeguard against this.
 <span class="keyword">*</span> <span class="variable">&lt;p&gt;</span>
 <span class="keyword">*</span> Input: Nothing.
 <span class="keyword">*</span> <span class="variable">&lt;p&gt;</span>
 <span class="keyword">*</span> Output: Nothing.
 <span class="keyword">*</span>/
<span class="comment">@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)</span>
public static final String ACTION_WIRELESS_SETTINGS =
        <span class="string">"android.settings.WIRELESS_SETTINGS"</span>;
</code></pre><p><strong>Settings内部类System</strong></p>
<p>系统设置表，包含各种各样的系统设置，以名值对的形式进行存储。System类提供了一些方便的方法去访问这些个人设置。</p>
<p>通过这个类，我们也可以把应用中的一些需要持久化保存的简单的数据保存到系统设置表，即使应用被卸载了，这些数据仍会存在。恢复出厂化设置，数据就会被清除了。</p>
<pre><code>Settings<span class="class">.System</span><span class="class">.putString</span>(<span class="function"><span class="title">getContentResolver</span><span class="params">()</span></span>, <span class="string">"crazymongo"</span>, <span class="string">"test system store"</span>)；
Settings<span class="class">.System</span><span class="class">.getString</span>(<span class="function"><span class="title">getContentResolver</span><span class="params">()</span></span>, <span class="string">"crazymongo"</span>)；
</code></pre><p><strong>Settings内部类Secure</strong></p>
<p>Secure system settings, containing system preferences that applications can read but are not allowed to write.  These are for preferences that the user must explicitly modify through the system UI or specialized APIs for those values, not modified directly by applications.（就不翻译了，Poor English）</p>
<p><strong>Settings内部类Global</strong></p>
<p>Global system settings, containing preferences that always apply identically to all defined users.  Applications can read these but are not allowed to write;like the “Secure” settings, these are for preferences that the user must explicitly modify through the system UI or specialized APIs for those values.</p>
<p><strong>Settings内部类Bookmarks</strong></p>
<p>User-defined bookmarks and shortcuts.  The target of each bookmark is an Intent URL, allowing it to be either a web page or a particular application activity.</p>
<p>在查看源码的的过程中发现ContentValues这个类，该类使用一个HashMap<string, object="">存储数据，并封装了一下常用的工具。</string,></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/25/Android-Settings类初识/" data-id="cik95uw01002b08pxn0fexhz6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-Settings/">Android Settings</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-plugin-for-gradle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/22/Android-plugin-for-gradle/" class="article-date">
  <time datetime="2015-12-22T09:03:37.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/Android-plugin-for-gradle/">Android_plugin_for_gradle</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android构建系统包含一个Android插件工具。Gradle是一个高级的构建工具，可以用来管理依赖，允许用户定义自己的构建逻辑。</p>
<p>The Android plugin for Gradle独立于AS运行。也就是说，我们不仅可以在AS中构建程序，也可以通过本机的命令行或者没有安装AS的机器上构建程序。无论通过哪种构建方式，结果都是相同的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/22/Android-plugin-for-gradle/" data-id="cik95uvzw002408pxsikwx893" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Class-forName作用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/15/Class-forName作用/" class="article-date">
  <time datetime="2015-12-15T08:05:44.000Z" itemprop="datePublished">2015-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/15/Class-forName作用/">Class.forName作用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Class.forName(“classname”)返回的是一个类Class。首先我们要明白在Java里面任何class都要装载在虚拟机上才可运行。这个方法就是用来装载类的（和new不一样，要分清楚）。</p>
<p>如何创建一个类实例？很多人首先想到的就是new这个关键字，没错，使用new关键字确实可以创建我们想要的类实例。不过还有一种方法，如下所示：</p>
<pre><code><span class="comment">//创建一个Person类的实例</span>
<span class="keyword">Class</span> mClass=<span class="keyword">Class</span>.forName(<span class="string">"Person类的完整类名"</span>);
Person person=mClass.newInstance();
</code></pre><p>那么这两种创建类实例的方法有什么不同吗？</p>
<p>首先创建对象的方式不一样，一个使用类加载机制，另一个是创建一个新类。那么为什么会有两种创建对象的方式？这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。</p>
<p>Java中工厂模式经常使用newInstance()方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。</p>
<p>从JVM的角度看，我们使用new创建一个类实例的时候，这个类可以没有被加载。但是使用newInstance()方法的时候，就必须要保证这个类已经加载，且这个类已经连接了。而完成上面两个步骤的正是forName()方法完成的，这个方法调用了启动类的加载器，即加载Java API的那个加载器。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Class</span>&lt;?&gt; forName(String className)
            <span class="keyword">throws</span> ClassNotFoundException {
    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>,
                    ClassLoader.getClassLoader(Reflection.getCallerClass()));
}
</code></pre><p>这个加载器也是加载Class的加载器。</p>
<p>现在可以看出，newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。这样分步的好处是显而易见的。我们可以在调用class的forName方法时获得更好的灵活性，提供了一种降耦的手段。</p>
<p>此外，newInstance()效率比较低，只能调用无参构造。</p>
<p>注意：静态代码是和Class绑定的，Class装载成功就表示执行了你的静态代码了。而且以后不会再走这段静态代码了。</p>
<p>通过Class.forName方法可以实现预加载功能，提高程序效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/15/Class-forName作用/" data-id="cik95uvzn001s08pxd9tifs1g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Class/">Java Class</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android百分比布局学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/13/Android百分比布局学习/" class="article-date">
  <time datetime="2015-12-13T11:08:49.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/Android百分比布局学习/">Android百分比布局学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android应用的适配问题，让很多人头痛过，我也不例外。前段时间看到Google提供了一个支持库，该支持库可以用来进行百分比的布局，对此支持库特别感兴趣，于是抱着学习的态度开始阅读其源码。</p>
<p>该支持库中只有三个类，包括：PercentFrameLayout，PercentRelativeLayout，PercentLayoutHelper。</p>
<p>查看源码之后，发现PercentRelativeLayout和PercentFrameLayout的实现方法几乎一模一样，都同属于一个模板。</p>
<p>下面是PercentFrameLayout的源码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercentFrameLayout</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> PercentLayoutHelper mHelper = <span class="keyword">new</span> PercentLayoutHelper(<span class="keyword">this</span>);

    <span class="function"><span class="keyword">public</span> <span class="title">PercentFrameLayout</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">super</span>(context);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">PercentFrameLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
        <span class="keyword">super</span>(context, attrs);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">PercentFrameLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>{
        <span class="keyword">super</span>(context, attrs, defStyleAttr);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(getContext(), attrs);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
        mHelper.adjustChildren(widthMeasureSpec, heightMeasureSpec);
        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);
        <span class="keyword">if</span> (mHelper.handleMeasuredStateTooSmall()) {
            <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>{
        <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);
        mHelper.restoreOriginalParams();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span>.<span class="title">LayoutParams</span>
            <span class="keyword">implements</span> <span class="title">PercentLayoutHelper</span>.<span class="title">PercentLayoutParams</span> </span>{
        <span class="keyword">private</span> PercentLayoutHelper.PercentLayoutInfo mPercentLayoutInfo;

        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>{
            <span class="keyword">super</span>(c, attrs);
            mPercentLayoutInfo = PercentLayoutHelper.getPercentLayoutInfo(c, attrs);
        }

        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>{
            <span class="keyword">super</span>(width, height);
        }

        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> gravity)</span> </span>{
            <span class="keyword">super</span>(width, height, gravity);
        }

        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(ViewGroup.LayoutParams source)</span> </span>{
            <span class="keyword">super</span>(source);
        }

        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(MarginLayoutParams source)</span> </span>{
            <span class="keyword">super</span>(source);
        }

        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(FrameLayout.LayoutParams source)</span> </span>{
            <span class="keyword">super</span>((MarginLayoutParams) source);
            gravity = source.gravity;
        }

        <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(LayoutParams source)</span> </span>{
            <span class="keyword">this</span>((FrameLayout.LayoutParams) source);
            mPercentLayoutInfo = source.mPercentLayoutInfo;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> PercentLayoutHelper.<span class="function">PercentLayoutInfo <span class="title">getPercentLayoutInfo</span><span class="params">()</span> </span>{
            <span class="keyword">if</span> (mPercentLayoutInfo == <span class="keyword">null</span>) {
                mPercentLayoutInfo = <span class="keyword">new</span> PercentLayoutHelper.PercentLayoutInfo();
            }

            <span class="keyword">return</span> mPercentLayoutInfo;
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setBaseAttributes</span><span class="params">(TypedArray a, <span class="keyword">int</span> widthAttr, <span class="keyword">int</span> heightAttr)</span> </span>{
            PercentLayoutHelper.fetchWidthAndHeight(<span class="keyword">this</span>, a, widthAttr, heightAttr);
        }
    }
}
</code></pre><p>很明显，PercentFrameLayout是FrameLayout的一个子类，接下来，我将对每个函数逐个进行分析。</p>
<p><strong>首先是generateDefaultLayoutParams()函数</strong></p>
<p>通过该函数的名字，我们大概就能知道该函数的作用了，主要就是用来生成一个默认的布局参数。其主要是在addView(View child)之类的函数中使用，如果child本身没有设置布局参数，就通过该函数生成一个，作为该child的布局参数。</p>
<p><strong>generateLayoutParams(AttributeSet attrs)</strong></p>
<p>这个函数也是用来生成一个布局参数，不过该布局参数是根据AttributeSet（xml布局文件中设置的属性）生成的。该函数主要在填充布局的时候被调用，即当LayoutInflater.inflater()方法调用时。有一点我们要知道，此函数也是用来为子视图生成布局参数的，也就是说子视图的布局参数由父容器生成。</p>
<p><strong>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</strong></p>
<p>此函数主要用来测量每个视图的大小，因此，实现百分比布局时，自然而然的就要从这个函数入手。接下来就是实现百分比布局的关键点了，通过调用<br>PercentLayoutHelper.adjustChildren方法重新计算每个视图的大小，</p>
<p><strong>onLayout(boolean changed, int left, int top, int right, int bottom)</strong></p>
<p>在此函数中，每个子视图的layout方法将被调用。</p>
<p>下面我将对实现百分比布局的关键类PercentLayoutHelper进行分析：</p>
<p>首先先分析PercentLayoutInfo类，下面是其源码：</p>
<pre><code> <span class="comment">/**
 * Container for information about percentage dimensions and margins. It acts as an extension
 * for {@code LayoutParams}.
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PercentLayoutInfo</span> {
    <span class="keyword">public</span> <span class="keyword">float</span> widthPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> heightPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> leftMarginPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> topMarginPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> rightMarginPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> bottomMarginPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> startMarginPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> endMarginPercent;

    <span class="keyword">public</span> <span class="keyword">float</span> aspectRatio;

    <span class="comment">/* package */</span> final ViewGroup.MarginLayoutParams mPreservedParams;

    <span class="function"><span class="keyword">public</span> <span class="title">PercentLayoutInfo</span>(<span class="params"></span>) </span>{
        widthPercent = -<span class="number">1</span>f;
        heightPercent = -<span class="number">1</span>f;
        leftMarginPercent = -<span class="number">1</span>f;
        topMarginPercent = -<span class="number">1</span>f;
        rightMarginPercent = -<span class="number">1</span>f;
        bottomMarginPercent = -<span class="number">1</span>f;
        startMarginPercent = -<span class="number">1</span>f;
        endMarginPercent = -<span class="number">1</span>f;
        mPreservedParams = <span class="keyword">new</span> ViewGroup.MarginLayoutParams(<span class="number">0</span>, <span class="number">0</span>);
    }

    <span class="comment">/**
     * Fills {@code ViewGroup.LayoutParams} dimensions based on percentage values.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillLayoutParams</span>(<span class="params">ViewGroup.LayoutParams <span class="keyword">params</span>, <span class="keyword">int</span> widthHint,
            <span class="keyword">int</span> heightHint</span>) </span>{
        <span class="comment">// Preserve the original layout params, so we can restore them after the measure step.</span>
        mPreservedParams.width = <span class="keyword">params</span>.width;
        mPreservedParams.height = <span class="keyword">params</span>.height;

        <span class="comment">// We assume that width/height set to 0 means that value was unset. This might not</span>
        <span class="comment">// necessarily be true, as the user might explicitly set it to 0. However, we use this</span>
        <span class="comment">// information only for the aspect ratio. If the user set the aspect ratio attribute,</span>
        <span class="comment">// it means they accept or soon discover that it will be disregarded.</span>
        final boolean widthNotSet = <span class="keyword">params</span>.width == <span class="number">0</span> &amp;&amp; widthPercent &lt; <span class="number">0</span>;
        final boolean heightNotSet = <span class="keyword">params</span>.height == <span class="number">0</span> &amp;&amp; heightPercent &lt; <span class="number">0</span>;

        <span class="keyword">if</span> (widthPercent &gt;= <span class="number">0</span>) {
            <span class="keyword">params</span>.width = (<span class="keyword">int</span>) (widthHint * widthPercent);
        }

        <span class="keyword">if</span> (heightPercent &gt;= <span class="number">0</span>) {
            <span class="keyword">params</span>.height = (<span class="keyword">int</span>) (heightHint * heightPercent);
        }

        <span class="keyword">if</span> (aspectRatio &gt;= <span class="number">0</span>) {
            <span class="keyword">if</span> (widthNotSet) {
                <span class="keyword">params</span>.width = (<span class="keyword">int</span>) (<span class="keyword">params</span>.height * aspectRatio);
            }
            <span class="keyword">if</span> (heightNotSet) {
                <span class="keyword">params</span>.height = (<span class="keyword">int</span>) (<span class="keyword">params</span>.width / aspectRatio);
            }
        }

        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, <span class="string">"after fillLayoutParams: ("</span> + <span class="keyword">params</span>.width + <span class="string">", "</span> + <span class="keyword">params</span>.height + <span class="string">")"</span>);
        }
    }

    <span class="comment">/**
     * Fills {@code ViewGroup.MarginLayoutParams} dimensions and margins based on percentage
     * values.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillMarginLayoutParams</span>(<span class="params">ViewGroup.MarginLayoutParams <span class="keyword">params</span>, <span class="keyword">int</span> widthHint,
            <span class="keyword">int</span> heightHint</span>) </span>{
        fillLayoutParams(<span class="keyword">params</span>, widthHint, heightHint);

        <span class="comment">// Preserver the original margins, so we can restore them after the measure step.</span>
        mPreservedParams.leftMargin = <span class="keyword">params</span>.leftMargin;
        mPreservedParams.topMargin = <span class="keyword">params</span>.topMargin;
        mPreservedParams.rightMargin = <span class="keyword">params</span>.rightMargin;
        mPreservedParams.bottomMargin = <span class="keyword">params</span>.bottomMargin;
        MarginLayoutParamsCompat.setMarginStart(mPreservedParams,
                MarginLayoutParamsCompat.getMarginStart(<span class="keyword">params</span>));
        MarginLayoutParamsCompat.setMarginEnd(mPreservedParams,
                MarginLayoutParamsCompat.getMarginEnd(<span class="keyword">params</span>));

        <span class="keyword">if</span> (leftMarginPercent &gt;= <span class="number">0</span>) {
            <span class="keyword">params</span>.leftMargin = (<span class="keyword">int</span>) (widthHint * leftMarginPercent);
        }
        <span class="keyword">if</span> (topMarginPercent &gt;= <span class="number">0</span>) {
            <span class="keyword">params</span>.topMargin = (<span class="keyword">int</span>) (heightHint * topMarginPercent);
        }
        <span class="keyword">if</span> (rightMarginPercent &gt;= <span class="number">0</span>) {
            <span class="keyword">params</span>.rightMargin = (<span class="keyword">int</span>) (widthHint * rightMarginPercent);
        }
        <span class="keyword">if</span> (bottomMarginPercent &gt;= <span class="number">0</span>) {
            <span class="keyword">params</span>.bottomMargin = (<span class="keyword">int</span>) (heightHint * bottomMarginPercent);
        }
        <span class="keyword">if</span> (startMarginPercent &gt;= <span class="number">0</span>) {
            MarginLayoutParamsCompat.setMarginStart(<span class="keyword">params</span>,
                    (<span class="keyword">int</span>) (widthHint * startMarginPercent));
        }
        <span class="keyword">if</span> (endMarginPercent &gt;= <span class="number">0</span>) {
            MarginLayoutParamsCompat.setMarginEnd(<span class="keyword">params</span>,
                    (<span class="keyword">int</span>) (widthHint * endMarginPercent));
        }
        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, <span class="string">"after fillMarginLayoutParams: ("</span> + <span class="keyword">params</span>.width + <span class="string">", "</span> + <span class="keyword">params</span>.height
                    + <span class="string">")"</span>);
        }
    }

    @<span class="function">Override
    <span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>{
        <span class="keyword">return</span> String.format(<span class="string">"PercentLayoutInformation width: %f height %f, margins (%f, %f, "</span>
                        + <span class="string">" %f, %f, %f, %f)"</span>, widthPercent, heightPercent, leftMarginPercent,
                topMarginPercent, rightMarginPercent, bottomMarginPercent, startMarginPercent,
                endMarginPercent);

    }

    <span class="comment">/**
     * Restores original dimensions and margins after they were changed for percentage based
     * values. Calling this method only makes sense if you previously called
     * {@link PercentLayoutHelper.PercentLayoutInfo#fillMarginLayoutParams}.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMarginLayoutParams</span>(<span class="params">ViewGroup.MarginLayoutParams <span class="keyword">params</span></span>) </span>{
        restoreLayoutParams(<span class="keyword">params</span>);
        <span class="keyword">params</span>.leftMargin = mPreservedParams.leftMargin;
        <span class="keyword">params</span>.topMargin = mPreservedParams.topMargin;
        <span class="keyword">params</span>.rightMargin = mPreservedParams.rightMargin;
        <span class="keyword">params</span>.bottomMargin = mPreservedParams.bottomMargin;
        MarginLayoutParamsCompat.setMarginStart(<span class="keyword">params</span>,
                MarginLayoutParamsCompat.getMarginStart(mPreservedParams));
        MarginLayoutParamsCompat.setMarginEnd(<span class="keyword">params</span>,
                MarginLayoutParamsCompat.getMarginEnd(mPreservedParams));
    }

    <span class="comment">/**
     * Restores original dimensions after they were changed for percentage based values. Calling
     * this method only makes sense if you previously called
     * {@link PercentLayoutHelper.PercentLayoutInfo#fillLayoutParams}.
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreLayoutParams</span>(<span class="params">ViewGroup.LayoutParams <span class="keyword">params</span></span>) </span>{
        <span class="keyword">params</span>.width = mPreservedParams.width;
        <span class="keyword">params</span>.height = mPreservedParams.height;
    }
}
</code></pre><p>正如其所注释的那样，该类充当LayoutParams的扩展，包含尺寸和边距的百分比信息。其fillLayoutParams和fillMarginLayoutParams方法用来计算视图的宽和高，以及边距的具体大小。</p>
<p>静态方法PercentLayoutHelper.getPercentLayoutInfo(Context context, AttributeSet attrs)用来得到一个PercentLayoutInfo对象。</p>
<p>PercentLayoutHelper.adjustChildren(int widthMeasureSpec, int heightMeasureSpec)方法主要用来根据百分比属性计算具体的宽、高等参数。</p>
<p>PercentLayoutHelper.handleMeasuredStateTooSmall方法，主要处理子视图的大小是否需要重新调整。当子视图的具体宽高不足以包裹其内容大小，且子视图的宽高属性至少一个设置成WRAP_CONTENT，那么就会重新计算改视图的大小。</p>
<p>PercentLayoutHelper.restoreOriginalParams()方法用来恢复子视图原始布局参数，以供下次使用。</p>
<p>PercentLayoutHelper.fetchWidthAndHeight方法，在百分比布局类的布局参数的setBaseAttributes(TypedArray a, int widthAttr, int heightAttr)方法中被调用，其作用就是给布局参数的宽高属性赋值，从而避免抛出RuntimeException。因为在ViewGroup.LayoutParams类中setBaseAttributes(TypedArray a, int widthAttr, int heightAttr)的默认实现方法如下所示：</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">void</span> setBaseAttributes(TypedArray a, <span class="built_in">int</span> widthAttr, <span class="built_in">int</span> heightAttr) {
       <span class="variable">width</span> = a.getLayoutDimension(widthAttr, <span class="string">"layout_width"</span>);
       <span class="variable">height</span> = a.getLayoutDimension(heightAttr, <span class="string">"layout_height"</span>);
}
</code></pre><p>其中TypedArray.getLayoutDimension(int index, String name)方法在找不到名为name的相关属性时，会抛出RuntimeException异常。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/13/Android百分比布局学习/" data-id="cik95uvzs001y08px5ms6adbz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-百分比布局/">Android  百分比布局</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android屏幕方向切换问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/Android屏幕方向切换问题/" class="article-date">
  <time datetime="2015-12-09T13:04:17.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/Android屏幕方向切换问题/">Android屏幕方向切换问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开发过程中，遇到这样一个需求：用户可以在程序中切换横竖屏，并且程序也可以按照用户在系统中设定的旋转方式进行旋转。</p>
<p>在程序中切换横竖屏的方法如下：</p>
<pre><code>setRequestedOrientation<span class="list">(<span class="keyword">ActivityInfo</span>.SCREEN_ORIENTATION_PORTRAIT)</span><span class="comment">;</span>
setRequestedOrientation<span class="list">(<span class="keyword">ActivityInfo</span>.SCREEN_ORIENTATION_LANDSCAPE)</span><span class="comment">;</span>
</code></pre><p>在用户锁定屏幕方向时，上述两个方法足以满足需求；那么问题来了，当用户没有锁定屏幕方向，而是设置成自动旋转，上述两个方法就无法满足需求了，在强制横屏后，程序就无法进行自动旋转了。于是我加了下面的代码以解决该问题：</p>
<pre><code><span class="keyword">if</span>(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.ACCELEROMETER_ROTATION)==<span class="number">1</span>){
    <span class="comment">//当屏幕为自动旋转的状态下，强制横竖屏2s后，恢复页面的自动旋转        </span>
    mHandler.sendEmptyMessageDelayed(<span class="number">1</span>, <span class="number">2</span>*<span class="number">1000</span>);
}

<span class="keyword">private</span> Handler mHandler=<span class="keyword">new</span> Handler(){

    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{
        <span class="keyword">switch</span>(msg.what){
        <span class="keyword">case</span> <span class="number">1</span>:
            getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
            <span class="keyword">break</span>;
        }
    }
};
</code></pre><p>本以为万事大吉了，可是在使用过程中发现，如果在锁定屏幕方向的情况下，强制切换屏幕方向，然后在设置中打开自动旋转，悲剧，怎么这么多情况。于是想到了监听屏幕旋转设置状态的方法，可是找半天没有找到可用的方法。在浏览网页时，发现有人监听系统亮度改变事件，心中暗喜，哈哈，于是依葫芦画瓢，添加了如下代码：</p>
<pre><code>getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), <span class="keyword">true</span>, mContentObserver);

<span class="keyword">private</span> ContentObserver mContentObserver=<span class="keyword">new</span> ContentObserver(<span class="keyword">new</span> Handler()) {

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>{
        <span class="comment">// TODO Auto-generated method stub</span>
        <span class="keyword">super</span>.onChange(selfChange);
        <span class="keyword">try</span> {
            <span class="comment">//Control whether the accelerometer will be used to change screen orientation</span>
            <span class="keyword">if</span>(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.ACCELEROMETER_ROTATION)==<span class="number">1</span>){
                mHandler.sendEmptyMessageDelayed(<span class="number">1</span>, <span class="number">1000</span>);
            }
        } <span class="keyword">catch</span> (Exception e) {
            <span class="comment">// TODO Auto-generated catch block</span>
            e.printStackTrace();
        }
    }
};
</code></pre><p>到此，问题终于解决了，但是也注意到了ContentResolver这个类，我将在另外一篇文章中介绍该类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/09/Android屏幕方向切换问题/" data-id="cik95uvzu002108pxufrwoyu4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-屏幕切换/">Android 屏幕切换</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/09/闭包/" class="article-date">
  <time datetime="2015-12-09T03:31:00.000Z" itemprop="datePublished">2015-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/09/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/09/闭包/" data-id="cik95uvsg000308pxxgqzm4qs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/闭包/">闭包</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Servlet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/20/Servlet/" class="article-date">
  <time datetime="2015-11-20T06:52:25.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/20/Servlet/">Servlet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java Servlet是运行在Web服务器或应用服务器上的程序，它是作为来自Web浏览器或其他HTTP客户端的请求和服务器上的数据库或应用程序之间的中间层。</p>
<p>使用Servlet，可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
<p>Java Servlet通常情况下与使用CGI实现的程序可以达到异曲同工的效果。但是相比于CGI，Servlet有以下几点优势：</p>
<ul>
<li>性能明显更好</li>
<li>Servlet在Web服务器的地址空间内执行。这样它就没必要再创建一个单独的进程来处理每个客户端请求。</li>
<li>Servlet是独立于平台的，因为它们是用Java编写的。</li>
<li>服务器上的Java安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet是可信的。</li>
<li>Java类库的全部功能对Servlet来说都是可用的。它可以通过Sockets和RMI（Remote Method Invocation）机制与applets、数据库或其他软件进行交互。</li>
</ul>
<p><strong>Servlet生命周期</strong></p>
<p>Servlet声明周期可被定义为从创建直到销毁的整个过程。以下是Servlet遵循的过程：</p>
<ol>
<li>Servlet通过调用init()方法进行初始化。</li>
<li>Servlet通过调用service()方法来处理客户端的请求。</li>
<li>Servlet通过调用destory()方法终止。</li>
<li>最后，Servlet是由JVM的垃圾回收器进行垃圾回收的。</li>
</ol>
<p><strong>init() 方法</strong></p>
<p>init方法被设计成只调用一次。它在第一次创建Servlet时被调用，在后续每次用户请求时不再调用。</p>
<p>Servlet创建于用户第一次调用对应于该Servlet的URL时，但是也可以指定Servlet在服务器第一次启动时被加载。</p>
<p>当用户调用一个Servlet时，就会创建一个Servlet实例，每一个用户请求都会产生一个新的线程，适当的时候移交给doGet或doPost方法。init方法简单的创建或加载一些数据，这些数据将被用于Servlet的整个生命周期。</p>
<p>init() 方法定义如下：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span>{
    <span class="comment">//初始化代码···</span>
}
</code></pre><p><strong>service()方法</strong></p>
<p>service()方法是执行实际任务的主要方法。Servlet容器（即Web服务器）调用service()方法来处理来自客户端的请求，并把格式化的响应写回给客户端。</p>
<p>每次服务器接收到一个Servlet请求时，服务器会产生一个新的线程并调用服务。service()方法检查HTTP请求类型（GET、POST、PUT、DELETE等），并在适当的时候调用doGet、doPost、doPut、doDelete等方法。</p>
<p>service()方法定义如下：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOExcepion</span>{

}
</code></pre><p>service()方法由容器调用，service方法在适当的时候调用doGet、doPost、doPut、doDelete等方法。所以，不用对service()方法做任何动作，只需要根据来自客户端的请求类型来重载doGet() 或 doPost() 即可。</p>
<p><strong>doGet方法</strong></p>
<p>GET请求来自于一个URL的正常请求，或者来自于一个未指定METHOD的HTML表单，它由doGet()方法处理。</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span>{
    <span class="comment">//Servlet代码</span>
}
</code></pre><p><strong>doPost()方法</strong></p>
<p>POST请求来自于一个特别指定了METHOD为POST的HTML表单，它由doPost()方法处理</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span>{
    <span class="comment">//Servlet代码</span>
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/20/Servlet/" data-id="cik95uvsv000i08pxwp181ggy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Servlet/">Servlet</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CGI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/20/CGI/" class="article-date">
  <time datetime="2015-11-20T02:55:29.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/20/CGI/">CGI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CGI（Common Gateway Interface，通用网关接口）是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程。CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新的交互式媒体。</p>
<p>在物理上是一段程序，运行在服务器上，提供同客户端HTML页面的接口。举例来说：假如某个网页上有一个表单，先由用户在客户端输入一些信息，如名字之类的东西。接着用户提交表单内容，浏览器把这些信息传送到服务器的CGI目录下特定的CGI程序中，于是CGI程序在服务器上按照预定的方法进行处理。然后CGI程序给客户端发送一个信息，表示请求的任务已经结束。</p>
<p>绝大数的CGI程序被用来解释处理来自表单的输入信息，并在服务器产生相应的处理，或将相应的信息反馈给浏览器。CGI程序使网页具有交互功能。</p>
<p>处理步骤：</p>
<ol>
<li>浏览器通过网络把用户请求送到Web服务器</li>
<li>服务器接收用户请求并交给CGI程序处理</li>
<li>CGI程序把处理结果传送给web服务器</li>
<li>服务器把结果送回到用户</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/20/CGI/" data-id="cik95uvzp001v08px58xee1ip" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CGI/">CGI</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-百分比布局/">Android  百分比布局</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Handler/">Android Handler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Message/">Android Message</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Messenger/">Android Messenger</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Settings/">Android Settings</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-UniversalImageLoader-MemoryCache/">Android UniversalImageLoader MemoryCache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-屏幕切换/">Android 屏幕切换</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidStudio-Gradle/">AndroidStudio Gradle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CGI/">CGI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashSet-HashMap-Hashtable/">HashSet HashMap Hashtable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-ByteArrayOutputStream/">Java ByteArrayOutputStream</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Callable/">Java Callable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Class/">Java Class</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Closeable-Flushable/">Java Closeable Flushable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-DataOutput/">Java DataOutput</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Executor/">Java Executor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-ExecutorService/">Java ExecutorService</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-FilterOutputStream/">Java FilterOutputStream</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Future/">Java Future</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-泛型/">Java 泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/">Servlet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-EventBus/">android EventBus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/classloader/">classloader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-DataInput/">java DataInput</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-线程池/">java 线程池</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式-负载均衡算法/">分布式 负载均衡算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程技巧-对象池/">编程技巧 对象池</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/闭包/">闭包</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android-百分比布局/" style="font-size: 10px;">Android  百分比布局</a> <a href="/tags/Android-Handler/" style="font-size: 10px;">Android Handler</a> <a href="/tags/Android-Message/" style="font-size: 10px;">Android Message</a> <a href="/tags/Android-Messenger/" style="font-size: 10px;">Android Messenger</a> <a href="/tags/Android-Settings/" style="font-size: 10px;">Android Settings</a> <a href="/tags/Android-UniversalImageLoader-MemoryCache/" style="font-size: 10px;">Android UniversalImageLoader MemoryCache</a> <a href="/tags/Android-屏幕切换/" style="font-size: 10px;">Android 屏幕切换</a> <a href="/tags/AndroidStudio-Gradle/" style="font-size: 10px;">AndroidStudio Gradle</a> <a href="/tags/CGI/" style="font-size: 10px;">CGI</a> <a href="/tags/HashSet-HashMap-Hashtable/" style="font-size: 10px;">HashSet HashMap Hashtable</a> <a href="/tags/Java-ByteArrayOutputStream/" style="font-size: 10px;">Java ByteArrayOutputStream</a> <a href="/tags/Java-Callable/" style="font-size: 10px;">Java Callable</a> <a href="/tags/Java-Class/" style="font-size: 10px;">Java Class</a> <a href="/tags/Java-Closeable-Flushable/" style="font-size: 10px;">Java Closeable Flushable</a> <a href="/tags/Java-DataOutput/" style="font-size: 10px;">Java DataOutput</a> <a href="/tags/Java-Executor/" style="font-size: 10px;">Java Executor</a> <a href="/tags/Java-ExecutorService/" style="font-size: 10px;">Java ExecutorService</a> <a href="/tags/Java-FilterOutputStream/" style="font-size: 10px;">Java FilterOutputStream</a> <a href="/tags/Java-Future/" style="font-size: 10px;">Java Future</a> <a href="/tags/Java-泛型/" style="font-size: 10px;">Java 泛型</a> <a href="/tags/Servlet/" style="font-size: 10px;">Servlet</a> <a href="/tags/Volley/" style="font-size: 10px;">Volley</a> <a href="/tags/android-EventBus/" style="font-size: 10px;">android EventBus</a> <a href="/tags/classloader/" style="font-size: 10px;">classloader</a> <a href="/tags/java-DataInput/" style="font-size: 10px;">java DataInput</a> <a href="/tags/java-线程池/" style="font-size: 10px;">java 线程池</a> <a href="/tags/分布式-负载均衡算法/" style="font-size: 10px;">分布式 负载均衡算法</a> <a href="/tags/编程技巧-对象池/" style="font-size: 10px;">编程技巧 对象池</a> <a href="/tags/闭包/" style="font-size: 10px;">闭包</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">10</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/13/HashSet和HashMap/">HashSet、HashMap和Hashtable</a>
          </li>
        
          <li>
            <a href="/2016/01/03/Android-UniversalImageLoader-MemoryCache/">Android-UniversalImageLoader-MemoryCache</a>
          </li>
        
          <li>
            <a href="/2015/12/25/Android-Settings类初识/">Android-Settings类初识</a>
          </li>
        
          <li>
            <a href="/2015/12/22/Android-plugin-for-gradle/">Android_plugin_for_gradle</a>
          </li>
        
          <li>
            <a href="/2015/12/15/Class-forName作用/">Class.forName作用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 crazymongo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>